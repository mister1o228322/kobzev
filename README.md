Задание 1. СУБД (Кейс строительной компании)
Ответ:

1.1. Бюджетирование проектов

Тип СУБД: Реляционная (SQL), например PostgreSQL.

Почему: Обеспечивает строгую целостность данных (ACID-транзакции) и четкую структуру, что критически важно для финансовых операций и прогнозирования рисков.

1.1. Хеширование*

API для ускорения: Redis (использовать как кэш для результатов хеширования) или аппаратные API (Intel QAT), если проблема на стороне сервера.

1.2. Лендинги и CRM

Тип СУБД для лендингов: Документо-ориентированная NoSQL (MongoDB).

Почему: Гибкая схема данных позволяет быстро вносить изменения в поля форм на лендингах без миграций.

Тип СУБД для CRM: Реляционная (PostgreSQL) или та же MongoDB.

Почему: Если нужны сложные отчеты по воронке продаж — SQL. Если важна гибкость под каждого менеджера — MongoDB.

1.2. Одна СУБД для лендингов и CRM*

Да, можно. Использовать PostgreSQL.

Реализация: Для лендингов использовать тип данных JSONB/JSON (гибкое хранение произвольных полей лидов), а для CRM использовать классические реляционные таблицы или представления (SQL) для построения аналитики и отчетов.

1.3. База знаний (нормы и правила)

Тип СУБД: Документо-ориентированная (MongoDB) или простая реляционная (SQLite/MySQL).

Почему: Обеспечивает простую и понятную структуру (документы, папки, метки), легко масштабируется горизонтально при росте объема обучающих материалов.

1.3. Использование существующей СУБД*

Да, можно.

Реализация: Использовать ту же PostgreSQL (из п. 1.2). Создать таблицу knowledge_base с полями id, title, content (текст), department_id (ссылка на отдел) и parent_id (для иерархии). Это покроет задачу без размножения технологий.

1.4. Логистика (маршруты)

Тип СУБД: Реляционная с расширением для маршрутизации (PostgreSQL + pgRouting) или Графовая (Neo4j).

Почему: Задача логистики требует быстрой обработки связей (поиск кратчайшего пути, обход графов). pgRouting оптимизирован для таких геопространственных вычислений прямо в БД.

1.4. Подключение отдела закупок*

Лучше сформировать свою СУБД в связке.

Почему: Закупки оперируют табличными данными (поставщики, цены, договоры) — идеально под SQL (PostgreSQL). Логистика работает с графами (маршруты). Связка двух СУБД через API или брокер сообщений обеспечит надежность и разделение ответственности.

1.5. Одна СУБД для всех задач*

Да, условно можно.

СУБД: PostgreSQL (с расширениями).

Почему:

Бюджетирование: ACID-совместимые таблицы.
Лендинги/CRM: JSONB для гибкости.
База знаний: Классические таблицы.
Логистика: Расширение pgRouting.
Задание 2. Транзакции
Ответ:

2.1. Пополнение счета телефона (ручное)

Инициация: Пользователь вводит номер телефона и сумму в приложении банка, нажимает «Оплатить».

Блокировка средств: Банк проверяет наличие средств на счете и блокирует (резервирует) указанную сумму.

Отправка запроса: Банк формирует протокол и отправляет запрос в платежный шлюз оператора сотовой связи.

Валидация: Платежный шлюз оператора проверяет корректность номера и готовность принять платеж.

Списание и перевод: Банк получает подтверждение от оператора, списывает заблокированные средства и переводит их на транзитный счет оператора.

Зачисление и уведомление: Оператор зачисляет деньги на баланс абонента. Банк и оператор отправляют пользователю push-уведомления/SMS об успешной операции.

2.1. Автоплатеж*

Действия те же, но шаги 1 и 6 автоматизированы:

Триггер: Система оператора фиксирует снижение баланса ниже порогового значения и генерирует событие для банка (или банк сам проверяет баланс по расписанию).
Автоматическое уведомление: Вместо ручного ввода, система банка получает команду на пополнение.
Далее выполняется цикл Блокировка -> Отправка -> Валидация -> Списание -> Зачисление.
Уведомление: Банк и оператор присылают чеки об успешном автоматическом пополнении.
Задание 3. SQL vs NoSQL
Ответ:

3.1. Пять преимуществ SQL перед NoSQL

Строгая структура и целостность данных (ACID): Гарантируют непротиворечивость данных (особенно важно для финансов).

Мощный язык запросов (SQL): Позволяет строить сложные выборки с соединениями таблиц (JOIN), подзапросами и агрегацией.

Стандартизация: SQL — это универсальный язык, знания переносимы между разными СУБД.

Транзакционность: Поддержка атомарных операций, где либо выполняются все действия, либо ни одного (откат при сбое).

Зрелость и поддержка: Огромное сообщество, инструменты для администрирования и отчетности (BI-системы).

3.1. Преимущества NewSQL*

Перед SQL: Сохраняя реляционную модель и ACID, NewSQL системы (например, CockroachDB, TiDB) обеспечивают горизонтальное масштабирование, как у NoSQL. Классические SQL трудно масштабировать на сотни узлов.

Перед NoSQL: В отличие от NoSQL, NewSQL не жертвует согласованностью данных ради скорости. Они дают сильную согласованность (Strong Consistency) при высоких нагрузках, что позволяет использовать их для высоконагруженных финансовых систем.

Задание 4. Кластеры
Ответ:

Критерий выбора типа СУБД:
Выбор будет основываться на критерии «модели данных и согласованности».

Если данные хорошо структурированы и требуют сложных связей (JOIN) — выбираем NewSQL (распределенный SQL).

Если данные слабоструктурированы (логи, JSON) — выбираем NoSQL (как ScyllaDB или Cassandra).

Критически важна модель CP (Consistency/Partition tolerance) по CAP-теореме, чтобы данные не расходились на 1000 узлов.

Модель распределенных вычислений:
Лучше всего справится модель MapReduce в современной реализации, а именно — Apache Spark (вычисления в памяти).

Почему:

Масштабируемость: Spark разработан для работы на кластерах из тысяч машин, эффективно распределяя данные и код между ними.

In-Memory обработка: Хранит промежуточные данные в оперативной памяти, что в разы быстрее дисковых операций MapReduce (Hadoop).

Универсальность: Позволяет работать с любыми источниками (SQL, NoSQL, файлы) и выполнять как ETL, так и машинное обучение на собранных данных.

